#### BFC

`BFC` 全称：`Block Formatting Context`， 名为 **块级格式化上下文**

`W3C`官方解释为：`BFC`它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，`Block Formatting Context`提供了一个环境，`HTML`在这个环境中按照一定的规则进行布局。

MDN: **块格式化上下文**（Block Formatting Context，BFC）是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context

下列方式会创建块格式化上下文：

- 根元素（`<html>`）
- 浮动元素（[`float`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/float) 值不为 `none`）
- 绝对定位元素（[`position`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position) 值为 `absolute` 或 `fixed`）
- 行内块元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `inline-block`）
- 表格单元格（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `table-cell`，HTML 表格单元格默认值）
- 表格标题（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `table-caption`，HTML 表格标题默认值）
- 匿名表格单元格元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `table`、`table-row`、 `table-row-group`、`table-header-group`、`table-footer-group`（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 `inline-table`）
- [`overflow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow) 值不为 `visible`、`clip` 的块元素
- [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `flow-root` 的元素
- [`contain`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain) 值为 `layout`、`content` 或 `paint` 的元素
- 弹性元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `flex` 或 `inline-flex` 元素的直接子元素），如果它们本身既不是 [flex](https://developer.mozilla.org/zh-CN/docs/Glossary/Flex_Container)、[grid](https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Container) 也不是 [table](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_table) 容器
- 网格元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `grid` 或 `inline-grid` 元素的直接子元素），如果它们本身既不是 [flex](https://developer.mozilla.org/zh-CN/docs/Glossary/Flex_Container)、[grid](https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Container) 也不是 [table](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_table) 容器
- 多列容器（[`column-count`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count) 或 [`column-width` (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/column-width) 值不为 `auto`，包括`column-count` 为 `1`）
- `column-span` 值为 `all` 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 ([规范变更](https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51), [Chrome bug](https://bugs.chromium.org/p/chromium/issues/detail?id=709362))

BFC的主要作用有以下几个方面：

1. 内部块级元素的浮动清除：当一个元素内部包含浮动元素时，该元素可以创建一个BFC来清除内部浮动，使得元素的高度能够正确计算和包含浮动元素。
2. 边距折叠的控制：在一个BFC中，上下相邻的块级元素的边距会发生折叠（合并）现象。这种折叠行为可以通过创建多个BFC来控制和限制，以避免不希望的边距合并。
3. 自适应两栏布局：通过将父元素创建为一个BFC，可以实现一种自适应的两栏布局。其中一个栏可以设置为浮动或绝对定位，而另一个栏则会自动填充剩余空间。
4. 防止元素溢出：当一个元素创建了一个BFC时，它会形成一个独立的渲染上下文，可以防止其子元素溢出到其他元素的区域。
5. 清除浮动后的自适应高度：通过在包含浮动元素的容器上创建BFC，可以使容器能够自动适应内部浮动元素的高度，而不需要使用额外的清除浮动的技巧。

#### 箭头函数与普通函数

https://juejin.cn/post/7069943937577779214

声明方式不同: 

- 声明一个普通函数需要使用关键字`function`来完成，并且使用`function`既可以声明成一个**具名函数**也可以声明成一个**匿名函数**
- 声明一个箭头函数则只需要使用箭头就可以，无需使用关键字`function`，比普通函数声明更简洁。

this指向不同:

对于普通函数来说，内部的`this`指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的`this`对象，内部的`this`就是定义时上层作用域中的`this`。也就是说，箭头函数内部的`this`指向是固定的，相比之下，普通函数的`this`指向是可变的。

```
// ES6
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log('id:', _this.id);
  }, 100);
}
```

我们可以用call、apply、bind来改变普通函数的this指向，但是由于箭头函数的this指向在它定义时就已经确定了，永远指向它定义时的上层作用域中的this，所以使用这些方法永远也改变不了箭头函数`this`的指向。

箭头函数处于全局作用域中，则没有arguments

箭头函数处于普通函数的函数作用域中，arguments则是上层普通函数的arguments

ES6 引入 `rest` 参数，用于获取函数不定数量的参数数组，这个API是用来替代`arguments`的，形式为`...变量名`，rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中

rest参数与arguments的比较：

- 箭头函数和普通函数都可以使用`rest`参数，而`arguments`只能普通函数使用
- 接受参数`rest`比`arguments`更加灵活
- `rest`参数是一个真正的数组，而`arguments`是一个类数组对象，不能直接使用数组方法

箭头函数不能当作构造函数

因为箭头函数没有自己的`this`，它的`this`其实是继承了外层执行环境中的`this`，且`this`指向永远不会变，并且箭头函数没有原型`prototype`，没法让他的实例的`__proto__`属性指向，所以箭头函数也就无法作为构造函数，否则用`new`调用时会报错！

#### 在 `Promise` 中，`resolve`或者`reject`不会阻止`Promise`内的其余代码的执行

```
const p = new Promise((resolve,reject) => {
    console.log(0)
    reject()
    console.log(1)
    resolve()
    console.log(2)
  })
p.then(res => {
  console.log(3)
}).then(res => {
  console.log(4)
}).catch(res => {
  console.log(5)
}).then(res => {
  console.log(6)
}).catch(res => {
  console.log(7)
}).then(res => {
  console.log(8)
})
0 1 2 5 6 8
作者：菜猫子neko
链接：https://juejin.cn/post/7173865309185671181
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### Set Map



#### 从输入URL到呈现页面过程



#### 如何监听路由切换



#### 缓存机制



#### 浏览器安全方面



#### HTTP



#### Promise 控制并发



